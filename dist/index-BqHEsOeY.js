(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&o(r)}).observe(document,{childList:!0,subtree:!0});function n(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function o(s){if(s.ep)return;s.ep=!0;const i=n(s);fetch(s.href,i)}})();let v=null;const G={alpha:!1},K=(t,e)=>{const n={...G,...e},o=document.getElementById(t);if(!(o instanceof HTMLCanvasElement))throw new Error(`canvas елемент c id: '${t}' не найден`);return v=o.getContext("2d",{alpha:n.alpha}),{getCtx:H}},H=()=>{if(!v)throw new Error("Ошибка во время получения 2д контекста");return v},a={getCtx:H,setCtx:K},Y={gridSize:10,strokeStyle:"#ccc",lineWidth:.5},q=(t,e)=>{const n={...Y,...e},o=window.innerWidth,s=window.innerHeight;a.getCtx().strokeStyle=n.strokeStyle,a.getCtx().lineWidth=n.lineWidth;for(let i=0;i<=o;i++)a.getCtx().beginPath(),a.getCtx().moveTo(i*n.gridSize,0),a.getCtx().lineTo(i*n.gridSize,s*n.gridSize),a.getCtx().stroke(),a.getCtx().closePath();for(let i=0;i<=s;i++)a.getCtx().beginPath(),a.getCtx().moveTo(0,i*n.gridSize),a.getCtx().lineTo(o*n.gridSize,i*n.gridSize),a.getCtx().stroke(),a.getCtx().closePath();return l},_={strokeStyle:"#000",lineWidth:.5},Q=({path:t},e)=>{const n={..._,...e};a.getCtx().strokeStyle=n.strokeStyle,a.getCtx().lineWidth=n.lineWidth,a.getCtx().beginPath(),a.getCtx().moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)a.getCtx().lineTo(t[o].x,t[o].y);return a.getCtx().stroke(),l},Z={fillStyle:"#007bff"},tt=({rect:t},e)=>{const n={...Z,...e},{position:o,size:s}=t,i=s.width/2,r=s.height/2;return a.getCtx().fillStyle=n.fillStyle,a.getCtx().fillRect(o.x-i,o.y-r,s.width,s.height),l},p={rect:tt,line:Q,grid:q},et=t=>{p.rect({rect:{position:{x:0,y:0},size:{width:window.innerWidth*2,height:window.innerHeight*2}}},{fillStyle:t})},ot=t=>{for(const[e,n]of Object.entries(t)){const o=a.getCtx().canvas.style;if(!(e in o))throw new Error(`Свойство CSS "${e}" не поддерживается. Список поддерживаемых свойств:
 ${JSON.stringify(Object.keys(o))}`);o[e]=n}},m={bgColor:et,css:ot},P=t=>{for(const e in t){if(!(e in m))throw new Error(`Настройка "${e}" не поддерживается. Список доступных настроек: ${JSON.stringify(Object.keys(m))}`);m[e](t[e])}return l},S="canvas-board",nt=t=>{const e=I();return e?(localStorage.setItem(S,JSON.stringify([...e,t])),l):(localStorage.setItem(S,JSON.stringify([t])),l)},st=()=>{const t=I();if(t)for(const e of t){const n=p[e.tool.type];if(!n)throw Error(`'${e.tool.type}' инструмент не найден`);n(e.tool.data,e.tool.settings)}return l},I=()=>{const t=localStorage.getItem(S);return t?JSON.parse(t):null},R={saveDrawing:nt,loadDrawings:st};let w=null;const u=t=>{if(!w)throw Error(`Хендлеры для инструмента '${t}' не определены`);return{mouseDown:w.mouseDown,mouseMove:w.mouseMove,mouseUp:w.mouseUp}},it=t=>{w={mouseDown:t.mouseDown,mouseMove:t.mouseMove,mouseUp:t.mouseUp}},h=[];for(let t=0;t<256;++t)h.push((t+256).toString(16).slice(1));function rt(t,e=0){return(h[t[e+0]]+h[t[e+1]]+h[t[e+2]]+h[t[e+3]]+"-"+h[t[e+4]]+h[t[e+5]]+"-"+h[t[e+6]]+h[t[e+7]]+"-"+h[t[e+8]]+h[t[e+9]]+"-"+h[t[e+10]]+h[t[e+11]]+h[t[e+12]]+h[t[e+13]]+h[t[e+14]]+h[t[e+15]]).toLowerCase()}let C;const ct=new Uint8Array(16);function at(){if(!C){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");C=crypto.getRandomValues.bind(crypto)}return C(ct)}const ht=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),L={randomUUID:ht};function lt(t,e,n){if(L.randomUUID&&!e&&!t)return L.randomUUID();t=t||{};const o=t.random||(t.rng||at)();return o[6]=o[6]&15|64,o[8]=o[8]&63|128,rt(o)}let y=null,d=null,E=!1;const gt=t=>{y={x:t.offsetX,y:t.offsetY},E=!0,d={id:lt(),tool:{type:"rect",data:{rect:{position:y,size:{height:0,width:0}}},settings:{fillStyle:"blue"}},boundElem:[],activeTool:"rect"},R.saveDrawing(d)},dt=t=>{if(!y||!d||!E)return;const e=t.offsetX-y.x,n=t.offsetY-y.y;d.tool.data.rect.size={width:e,height:n},p.rect(d.tool.data)},ut=()=>{d&&(R.saveDrawing(d),E=!1,y=null,d=null)},yt={mouseDown:gt,mouseMove:dt,mouseUp:ut},x="rect",xt=()=>{it(yt),P({css:{cursor:"crosshair"}});const t=a.getCtx().canvas;return t.addEventListener("mousedown",u(x).mouseDown),t.addEventListener("mousemove",u(x).mouseMove),t.addEventListener("mouseup",u(x).mouseUp),l},ft=()=>{P({css:{cursor:"initial"}});const t=a.getCtx().canvas;return t.removeEventListener("mousedown",u(x).mouseDown),t.removeEventListener("mousemove",u(x).mouseMove),t.removeEventListener("mouseup",u(x).mouseUp),l},wt={activate:xt,deactivate:ft},N={rect:wt};let k=N.rect;const pt=t=>{const e=N[t];if(!e)throw Error(`Инструмент с типом '${t}' не найден`);return e},mt=t=>(k=pt(t),l),Ct=()=>k,vt={setActiveTool:mt,getActiveTool:Ct},St=()=>(a.getCtx().clearRect(0,0,a.getCtx().canvas.width,a.getCtx().canvas.height),l),zt=()=>{const t=window.devicePixelRatio,e=window.innerWidth,n=window.innerHeight;return a.getCtx().canvas.width=e*t,a.getCtx().canvas.height=n*t,a.getCtx().scale(t,t),a.getCtx().canvas.style.width=`${e}px`,a.getCtx().canvas.style.height=`${n}px`,l},A={clear:St,scale:zt},l={...p,...A,...R,...vt,updateSettings:P,getCtx:a.getCtx},bt={alpha:!1,bgColor:"#fff",css:{cursor:"initial"}},Pt=(t,e)=>{const{alpha:n,...o}={...bt,...e};return a.setCtx(t,{alpha:n}),A.clear().scale(),l.updateSettings(o),l},Rt=async(t,e,n)=>{for(const o of t.values())o.traversable&&(o.gCost=Math.abs(o.x-e.x)+Math.abs(o.y-e.y),o.hCost=Math.abs(o.x-n.x)+Math.abs(o.y-n.y),o.fCost=o.gCost+o.hCost)},$=t=>`${t.x},${t.y}`,z=t=>({x:Math.round(t.x),y:Math.round(t.y)}),Et=t=>t.map(z),$t=t=>{const e=new Map,n=t.width*t.height;for(let o=0;o<n;o++){const s=o%t.width,i=Math.floor(o/t.width),r=$({x:s,y:i});e.set(r,{x:s,y:i,traversable:!0,gCost:0,hCost:0,fCost:0})}return e},b=(t,e,n)=>{const o=$(e),s=t.get(o);if(!t.has(o)||!s)throw new Error(`${n} (${e.x}, ${e.y}) нет в графе`);return s},Dt=(t,e,n,o)=>{for(const{x:s,y:i}of e){const r=b(t,{x:s,y:i},"Препятствие");!(n.x===s&&n.y===i)&&!(o.x===s&&o.y===i)&&(r.traversable=!1)}},Tt=(t,e)=>{const n=[],o=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(const{x:s,y:i}of o){const r=$({x:e.x+s,y:e.y+i}),c=t.get(r);c&&n.push(c)}return n},Mt=t=>{const e=[];let n=t;for(;n;)e.push({x:n.x,y:n.y}),n=n.parent;return e.reverse()},Ot=async(t,e,n)=>{const o=new Set([e]),s=new Set;for(;o.size>0;){const i=Array.from(o).reduce((c,g)=>g.fCost<c.fCost?g:c);if(o.delete(i),s.add(i),i===n)return Mt(i);const r=Tt(t,i);for(const c of r){if(!c.traversable||s.has(c))continue;const g=i.gCost+1;(!o.has(c)||g<c.gCost)&&(c.parent=i,c.gCost=g,c.hCost=Math.abs(c.x-n.x)+Math.abs(c.y-n.y),c.fCost=c.gCost+c.hCost,o.has(c)||o.add(c))}}throw new Error("Путь не найден")},Ut=async t=>{const e=z(t.start),n=z(t.end),o=Et(t.obstacles),s=$t({start:e,end:n,obstacles:o,width:t.width,height:t.height});Dt(s,o,e,n);const i=b(s,e,"Начальной точки"),r=b(s,n,"Конечной точки");return await Rt(s,i,r),await Ot(s,i,r)},Lt=(t,e)=>{const{position:n,size:o}=e,s=o.width/2,i=o.height/2,r=t.x===n.x-s||t.x===n.x+s,c=t.y===n.y-i||t.y===n.y+i;return r?[90,270]:c?[0,180]:[]},Bt=t=>{const{position:e,size:n}=t,o=n.width/2,s=n.height/2,i=[];for(let r=e.x-o;r<=e.x+o;r++)i.push({x:r,y:e.y-s}),i.push({x:r,y:e.y+s});for(let r=e.y-s;r<=e.y+s;r++)i.push({x:e.x-o,y:r}),i.push({x:e.x+o,y:r});return i},Wt=(t,e,n)=>{const{position:o,size:s}=n,i=s.width/2,r=s.height/2,c=e.x===o.x-i||e.x===o.x+i,g=e.y===o.y-r||e.y===o.y+r;return c?t===90||t===270:g?t===0||t===180:!1},Ht=(t,e)=>{const{x:n,y:o}=t,{position:s,size:i}=e,r=i.width/2,c=i.height/2;return(n===s.x-r||n===s.x+r)&&o>=s.y-c&&o<=s.y+c||(o===s.y-c||o===s.y+c)&&n>=s.x-r&&n<=s.x+r},It=t=>t.size.width!==0&&t.size.height!==0,Nt=(t,e)=>{const n=t.position.x-t.size.width/2,o=t.position.x+t.size.width/2,s=t.position.y-t.size.height/2,i=t.position.y+t.size.height/2,r=e.position.x-e.size.width/2,c=e.position.x+e.size.width/2,g=e.position.y-e.size.height/2,F=e.position.y+e.size.height/2;return n<c&&o>r&&s<F&&i>g},B=(t,e,n)=>{if(!It(e))throw new Error(`Прямоугольник имеет нулевые размеры.
Текущие размеры: ширина = ${e.size.width}, высота = ${e.size.height}`);if(!Ht(t.point,e)){const o=Bt(e);throw new Error(`${n} не лежит на грани прямоугольника. Допустимые точки: ${JSON.stringify(o)}`)}if(!Wt(t.angle,t.point,e)){const o=Lt(t.point,e);throw new Error(`Угол ${n} не перпендикулярен грани прямоугольника. Допустимые углы: ${JSON.stringify(o)}`)}},kt=(t,e)=>{if(Nt(t,e))throw new Error("Прямоугольники пересекаются");const n=Math.max(t.position.x+t.size.width/2,e.position.x+e.size.width/2),o=Math.max(t.position.y+t.size.height/2,e.position.y+e.size.height/2);return{width:n*2,height:o*2}},W=t=>{const{position:e,size:n}=t,o=n.width/2,s=n.height/2,i=[];for(let r=e.x-o;r<=e.x+o;r++)for(let c=e.y-s;c<=e.y+s;c++)i.push({x:r,y:c});return i},f=async t=>{B(t.cPoint1,t.rect1,"Точка подсоединения 1"),B(t.cPoint2,t.rect2,"Точка подсоединения 2");const e=kt(t.rect1,t.rect2),n={start:t.cPoint1.point,end:t.cPoint2.point,obstacles:W(t.rect1).concat(W(t.rect2)),width:e.width,height:e.height};return await Ut(n)},At={position:{x:250,y:450},size:{width:35,height:175}},Vt={position:{x:300,y:450},size:{width:35,height:175}},Jt={position:{x:275,y:40},size:{width:50,height:50}},jt={position:{x:275,y:250},size:{width:100,height:175}},D={position:{x:275,y:110},size:{width:100,height:50}},T={position:{x:150,y:140},size:{width:25,height:25}},M={position:{x:400,y:140},size:{width:25,height:25}},O={position:{x:150,y:230},size:{width:50,height:75}},U={position:{x:400,y:230},size:{width:50,height:75}},V={position:{x:150,y:320},size:{width:25,height:25}},J={position:{x:400,y:320},size:{width:25,height:25}},Xt=await f({rect1:O,rect2:T,cPoint1:{point:{x:150,y:192.5},angle:0},cPoint2:{point:{x:150,y:152.5},angle:0}}),Ft=await f({rect1:T,rect2:D,cPoint1:{point:{x:150,y:127.5},angle:0},cPoint2:{point:{x:225,y:110},angle:90}}),Gt=await f({rect1:D,rect2:M,cPoint1:{angle:90,point:{x:325,y:110}},cPoint2:{angle:0,point:{x:399.5,y:127.5}}}),Kt=await f({rect1:M,rect2:U,cPoint1:{angle:0,point:{x:399.5,y:152.5}},cPoint2:{angle:0,point:{x:399.5,y:192.5}}}),Yt=await f({rect1:O,rect2:V,cPoint1:{point:{x:150,y:267.5},angle:0},cPoint2:{point:{x:150,y:307.5},angle:0}}),qt=await f({rect1:U,rect2:J,cPoint1:{point:{x:399.5,y:267.5},angle:0},cPoint2:{point:{x:399.5,y:307.5},angle:0}});function j(t,e){t.clear().scale().updateSettings({bgColor:"#fff"}).loadDrawings().grid(null).rect({rect:Jt}).rect({rect:D}).rect({rect:jt}).rect({rect:At}).rect({rect:Vt}).rect({rect:O}).rect({rect:U}).rect({rect:T}).rect({rect:M}).rect({rect:V}).rect({rect:J}).line({path:Xt}).line({path:Ft}).line({path:Gt}).line({path:Kt}).line({path:Yt}).line({path:qt}),window.requestAnimationFrame(()=>j(t))}async function X(){const t=Pt("board");j(t)}window.addEventListener("load",X,{once:!0});window.addEventListener("resize",X,{once:!0});
